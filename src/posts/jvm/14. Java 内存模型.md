---
date: 2024-07-12
category:
  - JAVA
tag:
  - JVM
excerpt: Java 内存模型，可以帮助了解 Java 内多线程的实现细节
order: 14
---

# Java 内存模型

Java 内存模型（JMM，Java Memory Model）的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节

## 主内存与工作内存

JMM 规定了 **所有的变量都存储在主内存**（Main Memory）中（虚拟机内存的一部分），**每条线程还有自己的工作内存**（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本

- 主内存不会存储方法参数和局部变量，他们是线程私有的，所以只会存储在工作内存中
- 主内存通常就是指虚拟机内存，而本地内存是一个抽象的概念，涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化，通常来说就是 CPU 的缓存

线程对变量的所有操作都 **必须在工作内存中进行**，而不能直接读写主内存中的数据。**不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成**

![](./md.assets/main_working.png)

<small>深入理解Java虚拟机（第3版） - 图12-2 线程、主内存、工作内存三者的交互关系</small>

## 内存间交互操作

关于主内存与工作内存之间具体的交互协议，JMM 中定义了以下 8 种操作来完成。JVM 实现时 **必须保证下面提及的每一种操作都是原子的、不可再分的**

| 操作 | 作用内存 | 作用 |
| :-: |:-: |:- |
| `lock`（锁定） | 主内存 | 把一个变量标识为 **线程独占** 的状态 |
| `unlock`（解锁） | 主内存 | 把一个处于锁定状态的变量 **释放** 出来，释放后的变量才可以被其他线程锁定 |
| `read`（读取） | 主内存 | 把一个变量的值从主内存传输到线程的工作内存中，以便随后的 `load` 动作使用 |
| `load`（载入） | 工作内存 | 把 `read` 操作从主内存中得到的变量值，放入工作内存的变量副本中 |
| `use`（使用） | 工作内存 | 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要 **使用变量的值** 的字节码指令时将会执行这个操作 |
| `assign`（赋值） | 工作内存 | 把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个 **给变量赋值** 的字节码指令时执行这个操作 |
| `store`（存储） | 工作内存 | 把一个变量的值从工作内存传送到主内存中，以便随后的 `write` 操作使用 |
| `write`（写入） | 主内存 | 把 `store` 操作从工作内存中得到的变量的值放入主内存的变量中 |

如果要把一个变量从主内存拷贝到工作内存，那就要 **按顺序执行 `read` 和 `load` 操作**，如果要把变量从工作内存同步回主内存，就要 **按顺序执行 `store` 和 `write` 操作**。JMM 只要求上述两个操作 **必须按顺序执行，但不要求是连续执行**，中间可插入其他指令

JMM 还规定了在执行上述 8 种基本操作时必须满足如下规则

- 不允许 `read` 和 `load`、`store` 和 `write` 操作之一单独出现
  - 即不允许一个变量从主内存读取了但工作内存不接收
  - 或者工作内存发起回写了但主内存不接受的情况出现

> 读取就得载入，存储就得写入

- 不允许一个线程丢弃它最近的 `assign` 操作
  - 即变量在工作内存中改变了之后必须把该变化同步回主内存

> 改了就得写入

- 不允许一个线程无原因地（没有发生过任何 `assign` 操作）把数据从线程的工作内存同步回主内存中

> 没改不要写入

- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量

> 工作内存不允许新建变量

- 一个变量在同一个时刻只允许一条线程对其进行 `lock` 操作，但 `lock` 操作可以被同一条线程重复执行多次，多次执行 `lock` 后，只有执行相同次数的 `unlock` 操作，变量才会被解锁

> 允许同一个线程对同一个变量多次加锁，解锁时需同时解相同次数的锁

- 如果对一个变量执行 `lock` 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 `load` 或 `assign` 操作以初始化变量的值

> 被加了锁的变量，要清空其他工作内存中的该变量

- 如果一个变量事先没有被 `lock` 操作锁定，那就不允许对它执行 `unlock` 操作，也不允许去 `unlock` 一个被其他线程锁定的变量

> 没加锁不允许解锁

- 对一个变量执行 `unlock` 操作之前，必须先把此变量同步回主内存中（执行 `store`、`write` 操作）

> 解锁前先写入

## 参考

- 深入理解Java虚拟机（第3版）
- [讲讲什么是 JMM](https://www.cnblogs.com/shoshana-kong/p/16741851.html)
