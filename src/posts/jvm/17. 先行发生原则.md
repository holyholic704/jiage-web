---
date: 2024-07-18
category:
  - JAVA
tag:
  - JVM
excerpt: 什么是先行发生（Happens-Before）原则，天然的先行发生原则
order: 17
---

# 先行发生原则

如果 JMM 中所有的有序性都仅靠 `volatile` 和 `synchronized` 来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写 Java 并发代码的时候并没有察觉到这一点，这是因为 Java 语言中有一个 **先行发生（Happens-Before）** 的原则

- 程序员需要 JMM 提供一个强的内存模型来编写代码；编译器和处理器希望 JMM 的约束越弱越好，这样它们就可以最可能多的做优化来提高性能
- 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序

## 规则

- 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前
- 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序

```shell
# 只要保证 A、B happens-before C，A 和 B 就可以进行重排序
A happens-before C
B happens-before C
```

## 天然的先行发生原则

对于程序员来说，自然不想要太过于关注底层实现，只要按照以下规则编写代码，就能保证操作间的强可见性

- 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作

> 单线程程序语义（As-If-Serial）

- 管程锁定规则：一个 `unlock` 操作先行发生于后面对同一个锁的 `lock` 操作

> 先有锁才能解锁

- `volatile` 变量规则：对一个 `volatile` 变量的写操作先行发生于后面对这个变量的读操作

> 每个 volatile 写操作的后面都插入一个 StoreLoad 屏障，确保在对该变量的读操作之前，对其的修改已被刷新到内存中

- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 `finalize` 方法的开始

> 先创建才能销毁

- 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论
- 线程启动规则：Thread 对象的 `start` 方法先行发生于此线程的每一个动作

> 先创建线程，才能执行该线程的相关操作

- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测

> 线程终止了也就无法再操作了

- 线程中断规则：对线程 `interrupt` 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

> 线程得先中断才能被其他线程检测到中断

## 参考

- 深入理解Java虚拟机（第3版）
