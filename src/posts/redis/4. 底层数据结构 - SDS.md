---
date: 2024-11-22
category:
  - 数据库
tag:
  - Redis
excerpt: Redis 为什么使用 SDS，SDS 的实现原理与优点
order: 4
---

# 简单动态字符串（SDS，Simple Dynamic String）

Redis 虽然是由 C 语言实现的，但并没有直接使用 C 语言的字符串表示，而是自己封装了 SDS 数据结构来表示字符串

## C 语言字符串的不足之处

### 字符串的结尾用 `\0` （空字符）表示

如果字符串里面就包含有 `\0`，字符串就会被截断，但一些二进制文件就可能包括空字符，因此无法用来保存二进制数据

![](.\md.assets\cstring.png)

<small>[为了拿捏 Redis 数据结构，我画了 40 张图（完整版） - C 语言字符串的缺陷](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247501112&idx=1&sn=e42b6c61c6747e2c2f3b890ab4e4b844&chksm=f98d8192cefa0884606c5284499d76eeb3966ac2d3de9fbc4a405448313dcf79eb41b7c9501e&scene=178&cur_album_id=1790401816640225283#rd)</small>

### 获取字符串长度的时间复杂度为 `O(n)`

获取字符串长度的 `strlen` 函数，需要遍历字符数组，直到遇到 `\0` 停止，然后才能返回字符串的长度

![](.\md.assets\clength.png)

<small>[为了拿捏 Redis 数据结构，我画了 40 张图（完整版） - C 语言字符串的缺陷](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247501112&idx=1&sn=e42b6c61c6747e2c2f3b890ab4e4b844&chksm=f98d8192cefa0884606c5284499d76eeb3966ac2d3de9fbc4a405448313dcf79eb41b7c9501e&scene=178&cur_album_id=1790401816640225283#rd)</small>

### 字符串操作函数不高效且不安全

C 语言的字符串不会记录自身的长度，如果空余的内存不足，会发生缓冲区溢出，造成程序运行终止

## SDS 的结构设计

```c
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

- `len`：字符串长度
- `alloc`：实际分配给字符数组的空间长度
- `flags`：SDS 的类型
- `buf[]`：字符数组，保存实际的数据

## SDS 的优点

### 二进制安全

二进制安全是指通过某种机制，保证读写字符串的时候不损害其内容。简而言之就是不会像 C 语言的字符串那样，字符串中有 `\0` 就截断了

- 可通过 `len` 的值来判断字符串是否结束

### 获取字符串长度的时间复杂度为 `O(1)`

直接返回 `len` 的值

### 动态扩容且不会发生缓冲区溢出

在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，如果空间不能满足修改的需求，则会先将 SDS 的空间扩展到合适的大小，再执行修改的操作

- 只当空间不足的时候才会扩容，可有效的减少内存分配次数

### 兼容性

SDS 的数据实际都存放在 `buf[]` 中，且向外暴露的指针也是直接指向 `buf[]` 的，而且 SDS 为了兼容性，还是会在字符串结尾加上 `\0` 字符。这样就可以像读取 C 语言字符串一样读取 SDS 中的内容了，兼容了 C 语言处理字符串的各种函数

### 节省内存空间

SDS 为了能灵活保存不同大小的字符串，从而能有效节省内存空间，设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，他们对应的 `len`、`alloc` 变量的数据类型是不同的，在初始化时，Redis 会根据长度选择更小的类型，以减少内存的使用

SDS 还使用了专门的编译优化来节省内存空间，会告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐

## 参考

- [为了拿捏 Redis 数据结构，我画了 40 张图（完整版）](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247501112&idx=1&sn=e42b6c61c6747e2c2f3b890ab4e4b844&chksm=f98d8192cefa0884606c5284499d76eeb3966ac2d3de9fbc4a405448313dcf79eb41b7c9501e&scene=178&cur_album_id=1790401816640225283#rd)
- [分类：Redis - Error's Blog](https://zygzyg.cloud/categories/redis)
- [【高阶篇】3.3 Redis之底层数据结构简单动态字符串(SDS)详解](https://blog.csdn.net/wangshuai6707/article/details/131101404)
