---
icon: pen-to-square
date: 2024-04-03
category:
  - Redis
  - 数据库
tag:
  - Redis
excerpt: Redis 是一个开源的，基于键值对（key-value）的非关系型数据库（NoSQL）数据库
order: 1
---

# 一、Redis

Redis 是一个开源的，基于键值对（key-value）的 **非关系型数据库**（NoSQL）数据库，对数据的读写操作都是在内存中完成，因此 **读写速度非常快**，常用于 **缓存，消息队列、分布式锁等场景**

## 为什么快

Redis 执行命令的速度非常快，官方给出的数字是读写性能可以达到 **10 万/秒**

1. **所有数据都是存放在内存中**
    - 数据在内存中与在硬盘中的读写效率可谓一个天上一个地下
2. **由 C 语言实现**，并且源代码十分简洁且稳定
    - 一般来说 C 语言实现的程序距离操作系统更近，执行速度相对会更快
    - 精打细磨的源代码，曾经有人评价 Redis 是少有的集性能和优雅于一身的开源代码
3. 使用了 **单线程架构**，预防了多线程可能产生的竞争问题
    - 线程安全：采用了线程封闭的观念，把任务封闭在一个线程，自然就避免了线程安全问题，所以 **Redis 的所有操作都是原子性的**，同时还支持对几个操作合并后的原子性执行
4. Redis 使用 **IO 多路复用** 模型，避免了线程上下文切换和系统调用带来的开销，从而大幅提高了并发吞吐量
5. **数据结构优化**
    - 内置了多种优化过后的数据类型与结构，性能非常高

## 缺点

1. **数据库容量受到物理内存的限制**，不能用作海量数据的高性能读写
   - 一般只缓存一些常用或重要的数据
2. **较难支持在线扩容**，在集群容量达到上限时在线扩容会变得很复杂。所以在上线时必须确保有足够的空间，这对资源造成了很大的浪费

## Redis 是单线程的吗

我们常说 Redis 是单线程的，这个说法其实不太准确。**目前只有命令操作还在使用单线程**，其他的功能都是由额外的线程执行的。在 6.0 版本之前网络 IO 也采用的是单线程，现在也改为了多线程

### 单线程的优势

- 可以避免频繁的上下文切换
- 多线程开发中并发访问控制较复杂，增加了系统复杂度。需要额外的操作来保证线程安全，如果频繁发生对共享资源的争夺，会造成大量不必要的性能损耗

### 单线程的劣势

- 无法发挥多核 CPU 的优势
  - 不能同时处理多个任务
- 如果某个任务比较耗时的话，会导致服务阻塞
  - 例如删除大 key
- QPS（每秒查询率） 达到瓶颈

### 后台线程

- Redis 在 2.6 版本，会启动 2 个后台线程，分别处理 **关闭文件**、**AOF 刷盘** 这两个任务
- Redis 在 4.0 版本之后，新增了 **lazyfree** 线程，用来异步释放 Redis 内存

Redis 创建这些后台线程，是因为这些操作都很耗时，如果都交给主线程来处理，很容易导致主线程阻塞

![](.\md.assets\bio.png)

<small>[小林coding - Redis 线程模型](https://xiaolincoding.com/redis/base/redis_interview.html)</small>

- BIO_CLOSE_FILE：关闭文件时，释放相关资源
- BIO_AOF_FSYNC：将内核缓冲区的数据刷新到磁盘中
- BIO_LAZY_FREE：惰性删除，根据具体命令的损耗来选择立即处理还是延迟处理

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者不停轮询这个队列，拿出任务就去执行对应的方法即可

- Redis 在启动时，会同时启动这三个后台线程，但后台线程只有在需要执行相关类型后台任务时才会唤醒，其他时间会休眠等待任务

### Redis 6.0 多线程

Redis 认为 CPU 并不是制约性能的瓶颈，更多情况下是受到内存大小和网络 IO 的限制。且使用单线程，可维护性高，避免了并发读写的一系列问题

多线程是 Redis 6.0 推出的一个新特性。随着网络硬件的性能提升，单个线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈

Redis 6.0 的多线程特性默认只处理写请求，而如果想读请求也使用多线程来处理，则需要修改配置

```bash
# 读请求也使用IO多线程
io-threads-do-reads yes

# IO多线程个数
# 建议数量小于CPU核心数
# 注意主线程也算一个IO线程，所以最终会启动 n - 1 个IO线程
io-threads 4
```

### 多进程

当 Redis 需要处理一些重负荷任务时，会 fork 一个子进程来处理

- 收到 `bgsave` 命令：触发 **RDB 持久化**
  1. 子进程将内存中的所有数据写入到临时 RDB 文件中
  2. 当子进程完成对新 RDB 文件的写入时，用新 RDB 文件覆盖旧的 RDB 文件
- 收到 `bgrewriteaof` 命令：触发 **AOF 重写**
  1. 子进程往临时 AOF 文件中写入重建数据库状态的所有命令
  2. 写入完毕后，子进程会通知父进程把新增的写操作追加到临时 AOF 文件
  3. 最后将临时文件替换旧的 AOF 文件，并重命名
- 当需要进行 **全量复制** 时
  1. master 构建子进程，子进程将数据库快照保存到 RDB 文件
  2. 在写完 RDB 文件后，master 会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave

## IO 多路复用

由于读写操作等待用户输入输出都是阻塞的，所以 IO 操作在一般情况下往往不能直接返回结果，这就会导致阻塞，致使整个进程无法为其他用户提供服务

为了让单线程的服务能同时应对多个客户端的请求，Redis 采用了 IO 多路复用模型

IO 多路复用其实是使用一个线程来检查多个文件描述符（比如 Socket）的就绪状态，多路复用的函数将返回变化的文件描述符

![](.\md.assets\epoll.png)

<small>[Redis之I/O多路复用模型实现原理 - I/O多路复用](https://blog.csdn.net/Seky_fei/article/details/106677043)</small>

## 通用命令

Redis 命令 **大小写不敏感**

```bash
# 通过正则表达式查找key
# 常用keys *查找所有key
keys <pattern>

# 查看key总数
dbsize

# 检查key是否存在
exists <key>

# 删除指定key及其对应的值
del <key>

# 修改key的名称
rename <key> <newkey>

# 设置过期时间
expire <key> <seconds>

# 查看key的剩余过期时间
# 返回-1，该key未设置过期时间
# 返回-2，该key不存在
ttl <key>

# 移除key的过期时间
persist <key>

# 查看key的数据类型
type <key>

# 查看key的内部编码
object encoding <key>

# 清除数据库
flushall

# 随机返回一个key
randomkey
```

## 参考

- [面试官：你确定 Redis 是单线程的进程吗？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247516338&idx=2&sn=481c0c5ba605eddbc4824056d941a261&chksm=f98dc418cefa4d0ec4e8e3e2a1c1badc6cb66b5c20775ff785b8ef0da708cf8eb0a1c42c236f&scene=178&cur_album_id=1790401816640225283#rd)
- [面试官问，Redis 是单线程还是多线程?我懵了](https://segmentfault.com/a/1190000041275783)
- [Redis之I/O多路复用模型实现原理](https://blog.csdn.net/Seky_fei/article/details/106677043)
- [单线程的优缺点是什么？](https://www.zhihu.com/question/635375162)
- [Redis 6.0之前真的是单个线程吗？（后台线程那些事）](https://juejin.cn/post/7102780434739626014#heading-5)
