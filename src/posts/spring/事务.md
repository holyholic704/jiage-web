# 事务

事务是逻辑上的一组操作，要么都执行，要么都不执行

Spring 事务是由数据库的事务支持的，Spring 本身是无法提供事务功能的。Spring 事务的提交和回滚是通过数据库的事务机制实现

## 事务隔离级别

- ISOLATION_DEFAULT：使用后端数据库默认的隔离级别
- ISOLATION_READ_UNCOMMITTED：读未提交
- ISOLATION_READ_COMMITTED：读已提交
- ISOLATION_REPEATABLE_READ：可重复读
- ISOLATION_SERIALIZABLE：串行化

## 事务传播机制

- PROPAGATION_REQUIRED：默认事务传播机制，如果当前存在事务，则加入该事务，如果当前没有事务，则创建一个新的事务
- PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务，如果当前没有事务，则以非事务的方式继续运行
- PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务，如果当前没有事务，则抛出异常
- PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则挂起当前事务
- PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则挂起当前事务
- PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常
- PROPAGATION_NESTED：如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，则创建一个新的事务
  - 在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在

<small>[面渣逆袭：Spring三十五问，四万字+五十图详解！建议收藏！ - 7种事务传播机制](https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ)</small>

## Spring 事务管理

### 编程式事务管理

代码侵入性大，自由度高，可以手动提交或回滚

- 使用 TransactionTemplate

```java
@Autowired
private TransactionTemplate transactionTemplate;

public void test() {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
            try {

                ...

            } catch (Exception e) {
                // 回滚
                transactionStatus.setRollbackOnly();
            }
        }
    });
}
```

- 使用 PlatformTransactionManager

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void test() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {

        ...

        // 手动提交
        transactionManager.commit(status);
    } catch (Exception e) {
        // 回滚
        transactionManager.rollback(status);
    }
}
```

### 声明式事务管理

使用 `@Transactional` 注解，代码侵入性小，使用方便，通过 AOP 实现

## `@Transactional` 注解

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {

    @AliasFor("transactionManager")
    String value() default "";

    @AliasFor("value")
    String transactionManager() default "";

    // 事务传播机制
    Propagation propagation() default Propagation.REQUIRED;

    // 事务隔离级别
    Isolation isolation() default Isolation.DEFAULT;

    // 事务超时时间
    // 事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务
    // 默认-1
    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

    // 只读事务
    // 只读事务不涉及数据的修改，数据库会提供一些优化手段
    boolean readOnly() default false;

    // 指定哪些异常会触发回滚
    Class<? extends Throwable>[] rollbackFor() default {};

    String[] rollbackForClassName() default {};

    Class<? extends Throwable>[] noRollbackFor() default {};

    String[] noRollbackForClassName() default {};
}
```

## 原理

基于 AOP 实现。如果一个类使用了 `@Transactional` 注解的话，Spring 容器就会在启动的时候为其创建一个代理对象。当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强

## 注意事项

- 只能作用于 public 修饰的方法
- 避免自调用
- 正确的设置 rollbackFor 和 propagation 属性

## 参考

- [Spring常见面试题总结](https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html)
- [面渣逆袭：Spring三十五问，四万字+五十图详解！建议收藏！](https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ)
- [Spring 事务详解](https://javaguide.cn/system-design/framework/spring/spring-transaction.html)
