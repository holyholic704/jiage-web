---
date: 2024-06-07
category:
  - 数据库
tag:
  - MySQL
  - 索引
excerpt: 索引使用的数据结构及索引的分类
order: 3
---

# 索引

## 为什么使用 B+ 树作为索引的底层数据结构

### 二叉查找树（BST，Binary Search Tree）

![](./md.assets/bst_1.png)

<small>[【深入学习MySQL】MySQL的索引结构为什么使用B+树？ - 二叉查找树(BST)：不平衡](https://www.cnblogs.com/kismetv/p/11582214.html)</small>

- 左子树上的所有节点均小于它的根节点的值
- 右子树上的所有节点均大于它的根节点的值

当需要快速查找时，将数据存储在 BST 是一种常见的选择，查询时间取决于树高，平均时间复杂度是 `O(logn)`。但在某些情况下 BST 可能长歪而变得不平衡，此时 BST 退化为链表，时间复杂度退化为 `O(n)`

![](./md.assets/bst_2.png)

<small>[【深入学习MySQL】MySQL的索引结构为什么使用B+树？ - 二叉查找树(BST)：不平衡](https://www.cnblogs.com/kismetv/p/11582214.html)</small>

### 平衡二叉树（AVL Tree）

![](./md.assets/avl.jpg)

<small>[AVL树概念 AVL树旋转、插入、删除操作说明](https://fuxi.163.com/database/220)</small>

AVL 树是严格的平衡二叉树，**任一节点对应的两棵子树的最大高度差为 1**。AVL 树查找、插入和删除在平均和最坏情况下都是 `O(logn)`

AVL 树为了维护严格的平衡性，在插入或删除元素时，会进行大量的维护平衡的操作，维护平衡所需的代价可能高于其带来的好处，因此 AVL 树实际使用并不广泛

### 红黑树（R-B Tree）

与 AVL 树相比，红黑树并不追求严格的平衡，而是 **大致的平衡**，确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

![](./md.assets/Red-black_tree_example.svg.png)

<small>[红黑树](https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91)</small>

- 每个节点要么是黑色要么是红色
- 根节点是黑色
- 所有叶子节点都是黑色，并且为空节点
- 每个红色节点必须有两个黑色的子节点
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

红黑树允许少量的不平衡，省去了很多的平衡操作，也就有了更好的插入或删除的效率

对于数据在内存中的情况，红黑树的表现是非常优异的，但是对于数据在磁盘中的情况，红黑树并不擅长，因为红黑树长得还是太高了

当数据在磁盘中时，磁盘 IO 会成为最大的性能瓶颈，所以应该尽量减少 IO 次数。而树的高度越高，增删改查所需要的 IO 次数也越多，会严重影响性能

### B 树（B-Tree）

> 是 B 树，不是 B 减树哦，也并不存在这种树

B 树是为磁盘等辅存设备设计的多路平衡查找树，与二叉树相比，B 树的每个非叶节点可以有多个子树。因此，当总节点数量相同时，B 树的高度远远小于 AVL 树和红黑树，磁盘 IO 次数大大减少

![](./md.assets/b_tree.png)

<small>[B树和B+树的插入、删除图文详解 - B树](https://www.cnblogs.com/nullzx/p/8729425.html)</small>

B 树的优势除了树高小，还有对访问局部性原理的利用

- 局部性原理：当一个数据被使用时，其附近的数据有较大概率在短时间内被使用

B 树将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将该整个节点读到缓存中。当它临近的数据被访问时，可以直接在缓存中读取，无需进行磁盘 IO，换句话说，B 树的缓存命中率更高

### B+ 树（B+ Tree）

B+ 树是 B 树的一种变体

![](./md.assets/b+_tree.png)

<small>[B树和B+树的插入、删除图文详解 - B+树](https://www.cnblogs.com/nullzx/p/8729425.html)</small>

#### 与 B 树的区别

- B 树的所有节点既存储 key，又存储 data。B+ 树 **只有叶子节点存储 data**，其他节点只存储 key
  - B+ 树的一个节点可以存储更多的 key，使得 B+ 树相对于 B 树来说会更矮，磁盘 IO 次数也就更少
- B+ 树的叶子节点之间通过 **双向链表** 链接，并 **按照索引列的值进行排序**，**能更好支持范围查找**
  - B 树进行范围查询时，要先找到查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限
  - B+ 树进行范围查询时，只需要遍历链表即可
- B+ 树的查询效率更稳定，任何查找都是从根节点到叶子节点的过程。而 B 树每个节点都可能查找到数据，可能还没有到达叶子节点，检索就结束了，所以不稳定

B+ 树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势

### 哈希表（Hash）

哈希表是键值对的集合，通过 key 即可快速取出对应的 value，因此哈希表可以快速检索数据，接近 `O(1)`

- 使用哈希表，就可能会出现哈希冲突，数据量越大，发生冲突的概率也就越大。哈希冲突会产生性能损耗，并影响查询效率
- 哈希索引不支持顺序和范围查询，因为哈希表中数据是无序的

InnoDB 不直接支持常规的哈希索引，但是，InnoDB 中存在一种特殊的自适应哈希索引（Adaptive Hash Index）

- 自适应哈希索引结合了 B+ 树和哈希索引的特点，每个哈希桶实际上是一个小型的 B+ 树结构。这个 B+ 树结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率

## 聚簇索引（Clustered Index）与非聚簇索引（Non-Clustered Index）

聚簇索引是 **索引和数据一起存放** 的索引结构，例如主键索引

- 查询速度非常快：定位到索引的节点，就相当于定位到了数据
- 增删改时需要移动其他数据行，性能较差

非聚簇索引是 **索引和数据分开存放** 的索引结构，例如二级索引。叶子节点可以存放数据的指针，也可以存放主键值

- 可能会二次查询：即 **回表**，查到索引对应的指针或主键后，可能需要根据指针或主键再到数据文件或表中查询
- 增删改时不需要移动其他数据行，性能较好

> 一个是查询性能好，一个是修改性能好

### 主键索引

InnoDB 会 **自动** 的为每个表创建一个主键索引，叶子节点存储的是完整的用户记录

### 二级索引

叶子节点存储的是主键值。唯一索引、普通索引、前缀索引、全文索引等都属于二级索引

## 回表

由于二级索引中只包含索引列和主键，主键索引是包含完整的用户记录数据的，当需要获取其他非索引列的数据时，就需要进行回表，即用从二级索引中获取到的主键值，再去主键索引中进行查询

### 覆盖索引

为了避免回表操作带来的性能损耗，在搜索条件中最好只包含索引列，这样就不必到聚簇索引中再查找记录的剩余列

## 索引下推（ICP，Index Condition Pushdown）

索引下推主要用来减少回表次数，提高查询效率，存储引擎在索引遍历过程中，执行部分 `WHERE` 子句的判断条件，直接过滤掉不满足条件的记录

在没有索引下推前

1. server 层调用存储引擎的接口，定位到满足某一条件的第一条记录
2. 存储引擎根据该二级索引记录的主键值进行回表操作，将完整的用户记录返回给 server 层
3. server 层再判断其他的搜索条件是否成立，如果成立则将其发送给客户端，否则的话跳过该记录，然后向存储引擎层要下一条记录
4. 重复以上步骤，直到找到所有符合条件的记录

> 你以为 MySQL 是一次性向客户端返回多条数据的吗，其实是一次就查询一条数据并返回一条，客户端接收完完整的记录才会去展示

在有了索引下推后

1. server 层调用存储引擎的接口，定位到满足某一条件的第一条记录
2. 存储引擎先不进行回表操作，而是去 **判断其他搜索条件是否成立**（同一索引中的列，包括主键），如果成立，则执行回表操作，否则的话跳过该记录
3. server 层再判断剩下的搜索条件是否成立，如果成立则将其发送给客户端，否则的话跳过该记录，然后向存储引擎层要下一条记录
4. 重复以上步骤，直到找到所有符合条件的记录

> 以上说的回表操作不是必须的，只是用来表示没有使用到索引覆盖

## 索引的优缺点

使用索引可以大大加快数据的检索速度。通过创建唯一性索引，还可以保证数据库表中每一行数据的唯一性

- 减少服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机 IO 变为顺序 IO

创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间

## 参考

- [MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)
- [B树和B+树的插入、删除图文详解](https://www.cnblogs.com/nullzx/p/8729425.html)
- [MySQL B+树相对于B树的区别及优势](https://juejin.cn/post/7117516433386373133)
- [【深入学习MySQL】MySQL的索引结构为什么使用B+树？](https://www.cnblogs.com/kismetv/p/11582214.html)
- [MySQL索引详解](https://javaguide.cn/database/mysql/mysql-index.html)
