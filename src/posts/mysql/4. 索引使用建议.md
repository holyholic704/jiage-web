---
date: 2024-06-07
category:
  - 数据库
tag:
  - MySQL
  - 索引
excerpt: 索引创建与使用的注意事项
order: 4
---

# 索引使用建议

## 为合适的字段创建索引

- 不为 NULL 的字段
- 被作为条件查询的字段
- 频繁用于查询、排序、连接、分组的字段

## 考虑列的基数

列的基数指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中

因为列中的重复值过多，意味着需要大量的回表操作才能找到所需的数据，甚至会直接采用全表扫描而不走索引

最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好

## 索引列的类型尽量小

- 数据类型越小，占用的磁盘、内存和 CPU 缓存的空间更少，并且处理时需要的 CPU 周期也更少
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 IO 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率

主键更建议使用尽可能小的数据类型，因为聚簇索引、二级索引都会存储主键值，使用更小的数据类型，意味着节省更多的存储空间和更高效的 IO

## 索引字符串值的前缀

我们在 MySQL 中常用 utf8 字符集去存储字符串，编码一个字符需要占用 1 ~ 3 个字节。如果字符串很长，那存储一个字符串就需要占用很大的存储空间，并且建立索引时，占用的空间也很大，做字符串比较也会占用更多的时间

可以只对字符串的前几个字符进行索引，这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了

缺点是无法使用前缀索引做 ORDER BY 和 GROUP BY 操作，也无法使用前缀索引进行索引覆盖

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

`name(10)` 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码

## 避免重复冗余的索引

冗余和重复索引，只会增加维护的成本，并不会对搜索有什么好处

## 尽可能考虑组合索引

索引是需要占用磁盘空间的，如果一个表的索引过多，占用的空间也是很多的

如果使用联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

创建多个单列索引，在大部分情况下并不能提高查询性能。MySQL 引入了索引合并的策略，使用多个索引时，会对这些索引进行扫描，并将结果进行合并，会在算法的缓存、排序和合并操作上耗费大量 CPU 和内存资源

## 不要在频繁更新的列上创建索引

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的

## 使用 `EXPLAIN` 分析语句

使用 `EXPLAIN` 分析语句，查看语句是否走了索引，帮助我们更好的创建索引

## 避免使用 `SELECT *`

应指定需要查询的字段，尽量确保这些字段都在索引中，尽可能避免回表操作

## 遵守最左匹配原则

搜索条件中可以不用包含全部联合索引中的列，可以只包含左边一个或左边连续多个列

其实建立索引，也就是进行一个排序操作，先按字段 A 排，字段 A 相同时，再按 B 排，依次类推。如果跳过字段 A，直接使用字段 B 是走不了索引的，因为字段 B 只有在字段 A 相同时，才是有序的

### 不满足最左匹配原则也可以走索引

注意不满足最左匹配原则也不是就不能使用索引，在满足索引覆盖的前提下，也是可以走索引的，但需要遍历整个索引

遍历整个二级索引近似于全表扫描，但二级索引记录要比聚簇索记录小的多，而且因为满足了索引覆盖条件，所以也不不需要进行回表。所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多

```sql
# 为列A、B、C建立联合索引

# 走索引
# 只需要遍历索引中A=1的部分
SELECT A, B, C FROM test where A = 1;

# 走索引
# 但需要遍历整个索引
SELECT A, B, C FROM test where B = 1;

# 不能走索引，进行全表扫描
SELECT A, B, C, D FROM test where B = 1;
```

## 让索引列在比较表达式中单独出现

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的

```sql
# 无法使用索引
WHERE my_col * 2 < 4

# 可以使用索引
WHERE my_col < 4/2
```

## 避免使用 `%` 开头的模糊查询

对于字符串类型的索引列来说，只匹配它的前缀也是可以快速定位记录，因为字符串在排序时，也是逐个比较字符的大小的

但使用 `%` 开头的模糊查询是不走索引的，类似违反最左匹配原则

## 使用 `OR`

使用 `OR` 子句时，前后出现的列都要是索引列才可以走索引

## 使用 `IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`!=`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`LIKE`

这些操作都会产生一个需要扫描的范围，也就是扫描区间

优化器会首先针对可能使用到的二级索引划分几个扫描区间，然后分别调查这些区间内有多少条记录，在这些扫描区间内的二级索引记录的总和占总共的记录数量的比例达到某个值时，优化器将放弃使用二级索引执行查询，转而采用全表扫描

也就是说取值范围较大时会导致索引失效，走全表扫描

## 排序

`ORDER BY` 的子句后边的列的顺序也必须按照索引列的顺序给出，当然也适用最左匹配原则

- 注意不可 `ASC`、`DESC` 混用

## 隐式转换

当操作符左右两边的数据类型不一致时，会发生隐式转换，可能会导致索引失效，触发全表扫描。查询字段是什么类型的，查询条件就要保持相同的类型

## 参考

- [MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)
- 《高性能MySQL（第4版）》
