# 接口设计

## 参数校验

参数校验是我认为最重要的一步，实现简单，只需少量的代码就可以完成参数的校验，但可以帮我们过滤掉大量的无效请求，而且通过校验的数据，之后就可以放心使用时，就不需要再去浪费时间校验了

## 防抖

防抖操作就是将一段时间内的多次请求合并为一次请求，或者就只返回一次响应

接口防抖是必须要考虑到的一点，因为接口的重复请求是无法避免的，有可能是用户的重复点击，也有可能是由于网络波动发送了多次请求，读请求还稍微好点，写请求可能对我们的数据产生极大的破坏，而且哪怕是读请求，数据量上去了，我们的系统也扛不住

防抖的思路很简单，就是判断当次请求和之前收到的请求是否相同，不同才会响应

### 唯一 key

每次请求都会携带一个不同的唯一 key，后端通过这个 key 来判断当前的请求是否是重复请求

#### 随机 key

每次请求过来会携带一个随机 key，后端将这个 key 缓存下来，下次再有请求过来，就判断 key 是否在缓存中，如果在就不执行

#### 基于时间戳

与随机 key 类似，只不过判断的是时间间隔，有请求过来，就判断缓存中的时间戳与当次请求的间隔，间隔过短就不执行

#### 基于请求参数

每次请求过来时，都会将请求参数缓存下来，或者通过 Hash 算法（例如 MD5）算出一个值出来，后端通过缓存的值与当前的请求参数来判断是否是重复请求

### 业务锁

常用分布式锁实现，执行业务操作时先去获取锁，获取到锁后才能执行相应操作，之后的请求发现有锁就不再继续执行了

### token

1. 每次请求时都要先向后端发送一个获取 token 的请求
2. 后端生成一个 token 缓存下来并返回去
3. 请求方获取到了 token，再将本次的请求携带上这个 token 发送过去
4. 后端就判断这个 token 是否是自己之前生成的，如果不是，就不执行

## 幂等性

保证多次请求的结果是一致的，**针对的是增、改操作**，因为查、删操作是天然幂等的

幂等性和防抖很相似，二者都是为了避免重复请求造成的数据不一致现象，防抖是接受到多次请求，只会执行一次，因为多次请求的结果可能不一样，而幂等性是接受多少次请求，就执行多少次，所以就需要通过某些手段来保证多次请求的结果是一致的

### 数据库锁

数据库锁分为悲观锁和乐观锁两种，根据写的频率选择适合的锁

### 数据库唯一索引

只适用于新增操作，当数据出现重复时会抛出异常

### 去重表

类似唯一索引，只是将唯一索引放在了新的表中

## 权限控制

某些接口是不可被随意调用的，这时就可以通过权限控制，来判断这些请求者是否有请求某个接口的权限

## 限流

有时有些接口的访问过于频繁，特别是提供接口给第三方调用的时候，会对服务器造成极大的压力，影响系统的稳定性

## 黑白名单

黑名单较为常用，通常是某个人或某个 IP 频繁的大量的请求接口，或是执行一些恶意的请求，这时我们就可以将他们加入到黑名单中，避免他们对系统造成进一步的破坏

白名单使用的较少，一般只会为白名单内的请求方多添加些权限，或者直接就不行权限判断，给予所有权限

## 签名

签名主要是为了保证请求的安全性和完整性，避免数据在传输过程中被人恶意的篡改

1. 先将参数按照某种顺序排序（一般为 ASCII 码升序）
    - 哪怕参数相同，但顺序不同，得到的签名也是不同的
2. 参数拼接密钥，也就是加盐
    - 这一步是防止篡改，只要密钥不被人知道，其他人就无法生成正确的签名
3. 参数拼接 nonce（一次性随机数）
    - 这一步是防止重放攻击，就是合法请求被人截获了，攻击者就可以在之后重新发送这个请求
    - 也就是唯一 key 策略
4. 参数拼接上 timestamp（时间戳）
    - 这一步是判断请求是否超时，也可用来避免重放攻击
5. 调用签名算法生成签名，发送请求时携带上该签名

很显而易见的，签名的性能较差，使用签名校验的接口吞吐量肯定不高，所以需要尽量权衡

## 加密

在传输某些敏感数据时一定要对数据进行加密，并且建议使用非对称加密

如果使用了 HTTPS，可以不进行加密，HTTPS 可以保证数据在传输过程中的安全性，虽然数据仍有可能泄露的可能，比如说中间人攻击，但安全性已足够有保障，很多大厂（Github、Twitter 等）的密码也都是明文传输

- 中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制

## 版本控制

在日常开发中经常会有对系统的版本升级，在升级过程中可能导致某些旧接口不可用了，或者功能产生变化了，为此我们可以建立一个接口版本，旧的接口仍可继续向外提供服务，新的接口也可正常使用

## 响应

几乎所有的接口都是需要响应结果的，哪怕只是简单的插入数据的接口，通常也要返回一个插入成功的响应，而且不仅是成功要返回响应，失败或异常也都要返回响应

响应不止要返回结果，响应时间也要考虑到，在编写代码时应要注意整个接口的执行时间，尽量将响应时间降低到 100ms 以内，50ms 以内最佳

### 统一响应

我们一般会建立一个统一的响应格式，方便解析，易于理解。通常包括 3 个字段

- code（状态码）：通过 code 可快速的判断响应是否成功
- message（响应消息）：通常用于失败或异常响应，用来描述相应的原因
- data（响应数据）：存放请求方所需的数据

## 日志

将接口的请求参数、响应结果、异常记录下来，可以只记下大概的内容，还可以包括请求时间、请求 IP 等，方便出现问题时进行排查，也可用来分析接口的使用情况

## 文档

文档不是必须的，但建议为所有接口都编写一个可读性高的文档，方便提供给第三方调用，也方便自己之后的维护

## 参考

- [合集-优化接口设计的思路](https://www.cnblogs.com/wlovet/collections/8319)
- [如何实现接口幂等性](https://juejin.cn/post/7098355055610298404)
- [接口签名鉴权](https://wj.qq.com/docs/openapi/signature/)
- [Api接口签名](https://open.meituan.com/docs/introduce/sign)
- [第三方调用时 Nonce TimeStamp Signature 这三个参数有什么用？](https://blog.csdn.net/asfasfasgjkl/article/details/131422235)
- [设计一个接口至少要考虑这14点！](https://www.cnblogs.com/qdhxhz/p/16655103.html)
