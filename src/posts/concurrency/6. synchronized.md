---
date: 2024-07-16
category:
  - JAVA
tag:
  - 并发
excerpt: synchronized 的原理，如何保证原子性、可见性和有序性，JDK1.6 引入的一些锁优化手段
order: 6
---

# synchronized

在多线程环境中，常用锁来保证同一时间只有一个线程访问访问共享资源，从而避免数据竞争的问题，保证线程安全

- 锁主要保证的是操作的原子性
- 这里说的访问主要是修改操作，其实还有一种共享锁（读锁），同一时间可以允许有多个线程读取共享资源

Java 中通常使用 `synchronized` 来实现线程的同步，保证线程安全，不仅保障了原子性、可见性、有序性，还保证了可重入性

主要有三种使用方式

```java
// 修饰代码块，对给定的对象加锁
void method() {
    synchronized (this) {}
}

// 修饰实例方法，对当前实例加锁
synchronized void method() {}

// 修饰静态方法，对当前类加锁
synchronized static void method() {}
```

- Java 多线程的锁都是基于对象的，类锁其实也是对象锁，因为静态成员不属于任何⼀个实例对象，归整个类所有，所以类锁其实也就是该类的 **Class 对象的锁**

```java
public class Test extends Thread {

    @Override
    public void run() {
        try {
            methodSync();
            staticSync();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    synchronized void methodSync() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " - methodSync");
        Thread.sleep(1000);
    }

    synchronized static void staticSync() throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " - staticSync");
        Thread.sleep(1000);
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new Test(), "t1");
        Thread t2 = new Thread(new Test(), "t2");

        t1.start();
        t2.start();

        // 每隔 1 秒打印
        new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                System.out.println("-+------+-");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();
    }
}
```

> t2 - methodSync
t1 - methodSync
-+------+-
t2 - staticSync
-+------+-
t1 - staticSync
-+------+-

上述代码创建线程传入的是不同的对象，所以 `methodSync` 方法几乎是同时打印出来的，而 `staticSync` 是个静态同步方法，以类对象作为锁，所以 `staticSync` 差不多相隔 1 秒后才全部打印完成

## synchronized 原理

在 Java 中的锁都是基于对象的，而每个对象都有一个与之关联的监视器 Monitor（也叫做内部锁或 Monitor 锁），在 JVM 中由 ObjectMonitor 实现

线程在获取锁的时候，本质上是对一个对象监视器 Monitor 的获取，而且这个获取过程是排他的，即同一时刻只能有一个线程获取到该 Monitor

当某个线程想要调用 `synchronized` 语句块时，该线程必须先获取到某个对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入 BLOCKED 状态

### 修饰代码块

被 `synchronized` 修饰过的代码块前后会生成两个字节码指令：`monitorenter`、`monitorexit`，并且为了保障锁在同步代码块代码正常执行或出现异常都能被正确释放，多加了一个 `monitorexit` 指令

![](./md.assets/synchronized_block.png)

- `monitorenter`：线程试图获取 Monitor 的所有权
  - 每个对象中维护一个锁计数器，对象未被锁定时，计数器为 0
  - 线程成功获取到锁，计数器加 1
  - 同一线程如果再次获取到该锁，计数器再加 1
  - 如果计数器不为 0，其他线程尝试获取该对象的 Monitor 权限时，会被阻塞
- `monitorexit`：线程放弃 Monitor 的所有权，释放锁，所以执行 `monitorexit` 的线程必须是 Monitor 当前拥有者
  - 每执行一次，对象中锁计数器就减 1，直到减为 0，表明锁被释放，其他线程可以尝试获取锁

这也是为什么 `wait`、`notify`、`notifyAll` 方法必须在 `synchronized` 语句中使用

```java
void method() {
    synchronized (this) {
        System.out.println("hello");
    }
}
```

### 修饰方法

被 `synchronized` 修饰的方法不会加入 `monitorenter`、`monitorexit` 两个字节码指令，而是会在类文件中被标识为 ACC_SYNCHRONIZED，表示该方法为一个同步方法。当方法调用时，会先检查是否设置了该标识，如果设置了，执行线程就会先获取 Monitor，获取成功后再去执行方法体的内容

```java
synchronized void m1() {
}

synchronized static void m2() {
}
```

![](./md.assets/synchronized_method.png)

## 原子性、可见性与有序性

`synchronized`  原子性、可见性与有序性都是通过 JMM 中 `lock` 与 `unlock` 保证的

- `lock`（锁定）：把一个变量标识为 **线程独占** 的状态

- `unlock`（解锁）：把一个处于锁定状态的变量 **释放** 出来，释放后的变量才可以被其他线程锁定

### 原子性（Atomicity）

一个操作或者多个操作要么全部执行且执行的过程不会被任何因素打断，要么都不执行

`synchronized` 无论是修饰代码块，还是修饰方法，本质上都是为了获取 Monitor 锁，而且这个获取过程是排他的，即同一时刻只能有一个线程获取到该 Monitor，因此，`synchronized` 也就获得了原子性

### 可见性（Visibility）

对于共享变量的修改其他线程能及时可见

`synchronized` 的可见性是通过 JMM 中

- 如果对一个变量执行 `lock` 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 `load` 或 `assign` 操作以初始化变量的值
  - 进入 `synchronized` 语句块时，清空所有工作内存中该变量的副本

- 对一个变量执行 `unlock` 操作之前，必须先把此变量同步回主内存中（执行 `store`、`write` 操作）
  - 在离开 `synchronized` 语句块时，将变量的修改同步会主内存

### 有序性（Ordering）

如果在本线程内观察，所有的操作都是有序的

`synchronized` 的有序性是通过 JMM 中

- 一个变量在同一个时刻只允许一条线程对其进行 `lock` 操作，但 `lock` 操作可以被同一条线程重复执行多次，多次执行 `lock` 后，只有执行相同次数的 `unlock` 操作，变量才会被解锁

这个规则决定了 `synchronized` 语句块限制只能同时被一个线程访问，可以保证当前的操作不受其他线程的干扰。当然保证的是执行结果的有序性，指令还是可能会重排序，即串行语义（as-if-serial）

- as-if-serial 语义：所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的

## 可重入

`synchronized` 是可重入锁，允许同一个线程多次请求自己持有的锁，当然释放的时候也需要释放相同次数的锁

- 可重入锁也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不会产生死锁

`synchronized` 的可重入性也是通过 JMM 中

- 一个变量在同一个时刻只允许一条线程对其进行 `lock` 操作，但 `lock` 操作可以被同一条线程重复执行多次，多次执行 `lock` 后，只有执行相同次数的 `unlock` 操作，变量才会被解锁

## 锁优化

在 JDK1.6 为了减少获得锁和释放锁带来的性能消耗，对锁的实现引入了大量的优化

- 偏向锁
- 轻量级锁
- 自旋锁
  - 适应性自旋锁
- 锁粗化
- 锁消除

### 锁粗化

JVM 在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数

为了保证多线程间的高效并发，每个线程持有的锁的时间应该尽可能短，即加锁的粒度要小，以便当前线程使用完后，其他线程能更快的获取到资源。但如果对一个锁不停的进行请求、同步和释放，不仅不能提高性能，反而还浪费资源

```java
public void method() {
    synchronized (this) {
        System.out.println("one");
    }
    synchronized (this) {
        System.out.println("two");
    }
    synchronized (this) {
        System.out.println("three");
    }
}
```

```java
public void method() {
    synchronized (this) {
        System.out.println("one");
        System.out.println("two");
        System.out.println("three");
    }
}
```

锁粗化在开发中也可以应用，合适的锁粗化反而可以提高效率

```java
public class LockTest extends Thread {

    @Override
    public void run() {
        long n1 = System.currentTimeMillis();
        // synchronized (this) {
        for (int i = 0; i < 1000000; i++) {
            synchronized (this) {
                this.m1();
                this.m2();
            }
        }
        System.out.println(System.currentTimeMillis() - n1);
    }

    void m1() {
    }

    void m2() {
    }

    public static void main(String[] args) {
        LockTest lockTest = new LockTest();
        new Thread(lockTest).start();
        new Thread(lockTest).start();
    }
}
```

以上代码每次执行的时间都在几十毫秒，而如果把 `synchronized` 语句移到循环外，几毫秒就可以执行完毕

### 锁消除

JVM 在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间

```java
public synchronized void method() {
    System.out.println("one");
}
```

```java
public void method() {
    System.out.println("one");
}
```

### 锁升级

在 JDK1.6 之前所有的锁都是重量级锁，在 JDK1.6 之后扩展到了 4 种状态，根据锁在多线程中竞争的程度和状态，逐步进行升级，尽量减少性能消耗

- 锁升级的过程基本是不可逆的，虽然 JVM 是支持锁降级的，但条件较为苛刻

每个 Java 对象都有一个对象头，对象头里有一个称为 Mark Word 的部分，用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。根据锁的状态的不同，Mark Word 的结构也会不同

- Mark Word 的长度是根据及其字长来的，在 32 位和 64 位的虚拟机中分别为 32 个比特和 64 个比特

<table>
    <tr>
        <th align="center">锁状态</th>
        <th align="center" colspan="3" >29bit</th>
        <th align="center">可偏向（1bit）</th>
        <th align="center">锁标志位（2bit）</th>
    </tr>
    <tr>
        <td align="center">无锁</td>
        <td colspan="2" align="center">hashcode（31bit）</td>
        <td align="center">分代年龄（4bit）</td>
        <td align="center">0</td>
        <td align="center">01</td>
    </tr>
    <tr>
        <td align="center">偏向锁</td>
        <td align="center">线程ID（23bit）</td>
        <td align="center">epoch（2bit）</td>
        <td align="center">分代年龄（4bit）</td>
        <td align="center">1</td>
        <td align="center">01</td>
    </tr>
    <tr>
        <td align="center">轻量级锁</td>
        <td colspan="4" align="center">指向栈帧中锁记录的指针（30bit）</td>
        <td align="center">00</td>
    </tr>
    <tr>
        <td align="center">重量级锁</td>
        <td colspan="4" align="center">指向重量级锁的指针（30bit）</td>
        <td align="center">10</td>
    </tr>
    <tr>
        <td align="center">GC 标记</td>
        <td colspan="4" align="center">空</td>
        <td align="center">11</td>
    </tr>
</table>

<table>
    <tr>
        <th align="center">锁状态</th>
        <th align="center" colspan="4" >61bit</th>
        <th align="center">可偏向（1bit）</th>
        <th align="center">锁标志位（2bit）</th>
    </tr>
    <tr>
        <td align="center">无锁</td>
        <td align="center">unused（25bit）</td>
        <td align="center">hashcode（31bit）</td>
        <td align="center">unused（1bit）</td>
        <td align="center">分代年龄（4bit）</td>
        <td align="center">0</td>
        <td align="center">01</td>
    </tr>
    <tr>
        <td align="center">偏向锁</td>
        <td align="center">线程ID（54bit）</td>
        <td align="center">epoch（2bit）</td>
        <td align="center">unused（1bit）</td>
        <td align="center">分代年龄（4bit）</td>
        <td align="center">1</td>
        <td align="center">01</td>
    </tr>
    <tr>
        <td align="center">轻量级锁</td>
        <td colspan="5" align="center">指向栈帧中锁记录的指针（62bit）</td>
        <td align="center">00</td>
    </tr>
    <tr>
        <td align="center">重量级锁</td>
        <td colspan="5" align="center">指向重量级锁的指针（62bit）</td>
        <td align="center">10</td>
    </tr>
    <tr>
        <td align="center">GC 标记</td>
        <td colspan="5" align="center">空</td>
        <td align="center">11</td>
    </tr>
</table>


- unused：未使用的位置
- hashcode：hashcode 的值
- epoch：偏向时间戳

#### 无锁

没有对资源进行锁定，任何线程都可以尝试去修改它

#### 偏向锁

HotSpot  的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁

偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，偏向锁在资源无竞争情况下消除了同步语句，连 CAS 操作都不做了，提高了程序的运行性能

##### 偏向锁的获取

当一个线程在第一次进入同步块时，会在 Mark Word 中存储当前线程的 ID。当该线程再次进入这个同步块时，会去检查 Mark Word 里面是不是放的自己的线程 ID

- 如果是，则说明当前的线程已经获取到了锁，以后该线程在进入和退出同步块时都不需要花费 CAS 操作来加锁和解锁

- 如果不是，则表明有其他线程在竞争这个锁，这时就会使用 CAS 操作将存储的线程 ID 替换为当前线程的 ID

  - 如果替换成功，表示之前的线程已经不存在了，锁不会升级

  - 如果替换失败，表示之前的线程仍然存在，则升级为轻量级锁，再去竞争


当然偏向锁对于锁竞争比较激烈的场合效果不佳，可能每次都是不同的线程来请求同一把锁，还不如不用

```shell
# 关闭偏向锁
-XX:UseBiasedLocking=false
```

##### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以 **当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁**

- 这里说的释放其实是撤销，偏向锁的撤销是指有多个线程竞争时，告知锁对象不能再使用偏向模式了

偏向锁的撤销需等待到安全点（Safepoint），首先会暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活

- 如果仍存活，且该线程还在执行同步代码块中的代码
  - 撤销偏向锁，升级成轻量级锁
- 如果已死亡，或者该线程仍活着的线程但退出了同步块
  - 撤销偏向锁，将对象头重新设置成无锁状态

#### 轻量级锁

多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒

##### 轻量级锁的获取

一个线程在第一次进入同步块时，会先判断当前的锁是否已经是重量级锁，如果不是，则会在当前线程的栈帧中创建用于存储该锁的锁记录的空间（Displaced Mark Word），并将锁对象的 Mark Word 复制到里面

复制成功后，线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针

- 如果替换成功，则当前线程获得锁
- 如果替换失败，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁

自旋：不断尝试去获取锁，一般用循环来实现

- 减少线程上下文切换：线程是不知道什么时候能获取到锁，如果能够很快的获取到锁，那么将线程粗暴挂起反而得不偿失，为此通过自旋保持当前线程的运行，减少不必要的上下文切换
- 需要消耗 CPU，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费 CPU 资源

Java 采用了 **适应性自旋**，线程如果刚刚通过自旋成功获取到了锁，则其下次自旋的允许等待的时间会更长，如果某个线程很少能通过自旋获取到锁，则自旋的次数会相应减少，甚至直接被忽略掉

如果一个线程自旋超过 10 次（默认）仍未获取到锁，称为自旋失败，那么这个线程会阻塞，同时这个锁就会升级成重量级锁

#### 重量级锁

重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，且挂起线程和恢复线程都需要转入内核态来完成，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU

#### hashcode 的影响

对象在没有出现线程竞争时，即无锁状态，hashcode 会存储在 Mark Word 中。由于偏向锁没有存储 hashcode 的部分，所以在偏向锁模式下调用 `hashCode` 方法，会进行锁升级

- 在 `synchronized` 之前调用 `hashCode` 方法，偏向锁升级为轻量级锁
- 在 `synchronized` 之后调用 `hashCode` 方法，偏向锁升级为重量级锁

使用轻量级锁时，Mark Word 中会有一个指向栈帧中锁记录的指针，hashcode 也就存储在锁记录这里

使用重量级锁时，Mark Word 中会有一个指向重量级锁的指针，也就是 ObjectMonitor 对象，hashcode 也就存储在这里

## 与 `volatile` 的区别

`synchronized` 关键字和 `volatile` 关键字不是对立的而是 **互补** 的

- `volatile` 是线程同步的轻量级实现，所以 `volatile` 的性能要更好，但是 `volatile` 只能用于修饰变量，而 `synchronized` 可以修饰方法和代码块
- `volatile` 只能保证变量的可见性，不能保证原子性，而 `synchronized` 两者都能保证
- `volatile` 主要用于解决变量在多个线程之间的可见性，而 `synchronized` 主要解决的是多线程之间访问资源的同步性

## 参考

- 《实战Java高并发程序设计（第3版）》
- 《Java并发编程的艺术》
- [深入浅出Java多线程](http://concurrent.redspider.group/)
- [synchronized总结](https://blog.csdn.net/weixin_39559282/article/details/114273936)
- [Mark Word结构详解及分析对象在内存占用大小](https://blog.csdn.net/sbl19940819/article/details/126707169)
- [Java锁优化--JVM锁降级](https://www.jianshu.com/p/9932047a89be)
- [难搞的偏向锁终于被 Java 移除了](https://www.cnblogs.com/FraserYu/p/15743542.html)
- [synchronized原理-字节码分析、对象内存结构、锁升级过程、Monitor](https://juejin.cn/post/7367201514039263242)
